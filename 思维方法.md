# 思维方法总结归纳

https://www.bookstack.cn/read/The-Art-Of-Programming-By-July/ebook-zh-Readme.md

## 读题/表达

画图：数形结合；找规律

举例：易理解；易测试

分解：简化问题

一道题目用一种方法可能无法完全解决所有情况，所以特例可用特殊算法处理，即不同算法并存

> 规范性：命名规范，布局优雅
>
> 完整性：正确输入，错误输入，边界输入
>
> 鲁棒性：防御性编程，非法输入处理



## 搜索

搜索虽然听起来很暴力，很无脑，但是优化剪枝确是个很难的问题，涉及复杂排列组合问题更是烧脑，但目前已有的搜索方法比较系统，以下五种方法可以说是层层递进，具有不同的适用性和优缺点，需灵活选用。例如状态空间搜索时将整体看成一个状态节点（等于抽象了一层），然后搜索。

| 方法          | 适用条件/构造方法                                            | 优点             |                        |
| ------------- | ------------------------------------------------------------ | ---------------- | ---------------------- |
| 直接枚举      | 序列相关（长度为n的序列多少满足？多少个数满足？）            | 简单直观         | 效率不高               |
| 枚举子集/排列 | 递归/二进制构造子集；递归/next_permutaion构造全排列          |                  |                        |
| 回溯法        | 满足所有约束的解；递归枚举+剪枝（明确该分支不是正确答案，不深入）；搜索对象选取（天平难题），最优性剪枝（带宽），减少无用功（困难的串） | 减少搜索         | 剪枝条件分析难         |
| 状态空间搜索  | 初始到终止状态的路径；隐式图搜索（bfs/dfs+节点查找表）/双向广度优先/A* | 解决动态变化问题 | 判重难，减少空间状态难 |
| IDA           | 功能=回溯+状态空间搜索；**枚举上限，估值函数剪枝**           | 效率高           | 估值函数设计难         |

## 算法分析

### 最大连续子序列和

> 给定长度为n的序列`a1,a2,...,an`，计算最大的连续子序列和`Max(a(i)+a(i+1)+...+a(j)),0<i<=j<=n`

+ **直接求解**：双重循环枚举任意起点i和终点j，一重循环计算i到j的和，时间复杂度**O(n^3)**
+ **前缀和优化**：令`S[i]=a1+a2+...+ai`，即前i项和，用前缀和的差即可计算连续子序列和`S[j]-S[i-1]=i~j和`，将内层的一重循环优化为O(1)，因此，时间复杂度**O(n^2)**
+ **分治优化**
  + 划分：将序列划分为元素数量尽可能相等的两部分（左右两侧）
  + 递归求解：求出起点和终点均位于左侧或右侧的最佳序列
  + 合并：求解出起点在左侧，终点在右侧的最佳序列，与子问题解相比，取最优
  + 时间复杂度：`T(n)=2T(n/2)+n，T(1)=1 => O(nlogn)`，`T(n)表示长度为n的序列求解次数`
+ **前缀和再优化**：在前缀和优化的基础上，可以发现，假设j确定，那么`S[j]-S[i-1]`最大等价于`S[i-1]`取最小，因此，枚举j，与此同时维护目前遇到的最小S，一次遍历即可完成求解，时间复杂度**O(n)**

### 分治算法

#### 归并排序(O(nlogn))

+ 划分：将序列分为元素个数尽可能相等的两半
+ 递归求解：将两半元素分别排序
+ 合并：合并左右两个有序表（依次比较两个序列首尾，小者加入中间数组T）

#### 逆序对问题

> 问题描述：一序列`a1,a2,...,an，存在多少有序对(i,j)，使得ai>aj`

借用归并排序思想（和**最大连续子序列和类似，考虑三种情况，完全左/右侧，横跨两侧**）

+ 划分：将序列划分为元素尽可能相等的两半
+ 递归求解：计算i和j完全位于左侧或者右侧的逆序对个数
+ 合并：计算i和j分别位于左侧和右侧的逆序对个数（**在归并排序合并过程中，当右侧的A[j]复制到T中时，左侧未来得及复制到T中的元素就是大于A[j]的数**）

#### 快速排序

+ 划分：找到基准元素x，令x左侧均小于x，右侧均大于x（双指针）
+ 递归求解：对定位后的x左右侧递归划分
+ 无合并，已经有序

#### 选择第K大数

> 将一个序列升序排列后，第k个位置的数

借用快速排序思想，在划分完成后，可知`A[p...q]`被分为`A[p...x]和A[x+1,q]`，可根据`x-p+1和k`的大小关系觉得在左侧还是右侧递归求解，复杂度为O(n)

### 二分查找（必须有序）

+ `lower_bound`：找第一个大**于等于x**的下标L
+ `upper_bound`：找第一个**大于x**的下标R
+ `[L,R)`为全部均为x的子序列区间，`L==R`表示不存在x

### 滑动窗口

> 问题：给定正整数k和一个长度为n的序列A1,A2,...,An。定义f(i)表示从Ai开始的连续k个元素的最小值，即f(i)=min{Ai,Ai+1, ..., Ai+k-1 }。要求计算f(1),f(2),...,f(n-k+1)

+ **暴力枚举**：枚举每个点，并计算相应最小值，复杂度为`O((n-k+1)*k)`

+ **滑动窗口**：用set/优先队列/map存储当前区间的元素，第一个元素即最小，右移时，删除最左侧元素，增加最右侧元素，因此时间复杂度为`O((n-k+1)*logk)`

+ **单调队列**：当窗口存在相邻两个值a，b时，若a在b左侧且a>b，那么a不可能被选中，因此可删除a，以此类推，删除k个元素中所有无用元素后，得到一个单调递增序列（可有想等值），也就是一个单调队列，可用stl的deque实现，左侧即是答案。移动时，判断最左侧值是否为deque左侧值，若是，则删除，否则不操作；接着将所有比新增元素值大的元素删除。总的时间复杂度为`O(n)`

  若元素个数确定，比如上限10000个，可用数组和头指针front和为指针rear实现单调队列，具体实现需用到模运算，具体如下（不要用减法）

  | 指针\操作 | 插入            | 删除           |
  | --------- | --------------- | -------------- |
  | front     | (front+(n-1))%n | (front+1)%n    |
  | rear      | (rear+1)%n      | (rear+(n-1))%n |


### 拷贝复杂链表

  > 剑指offer-面试26
  >
  > 给定一个链表，除了指向下一个节点的pnext，还有指向该链表任意结点的sibling（可空）

**可以用节点指针来唯一标识结点，而不是用内部数值**

+ 算法1：先通过pnext构建简单单向链表，再遍历构建sibling，构建时需查找sibling指向，时间复杂度O(n^2)
+ 算法2：映射/map/哈希优化，建立二元组（当前结点，拷贝结点），查询只需O(1)，因此时间O(n),空间多消耗O(n)
+ 算法3：时间O(n)，空间优化为O(1)
  + 同步拷贝插入：扫描单向链表时将拷贝结点直接插入当前结点后
  + 同步构建连接：扫描链表，建立拷贝链表间的连接
  + 同步拆分链表：将奇数和偶数点拆分为两个链表

### 数组中重复数字

> 给定一个长度为n的整型数组，其中元素范围[0,n-1]。其中某些数字重复，求任意一个重复的值

+ 排序：直接排序，重复的数字必定相邻，时间复杂度O(nlogn)，空间复杂度O(1)
+ 哈希表：利用哈希表，统计每个元素出现次数，T(n)=S(O)=O(n)
+ 空间优化：假设不存在重复，那么该数组排序后必定满足ai=i，即下标为i的元素值也是i。枚举每个元素ai，若ai=i，则枚举下一个元素；否则，若ai=a(ai)，说明存在重复值，否则交换ai和a(ai)，继续判断处理ai。T(S)=O(n),S(O)=O(1)

## 数据结构

### 二叉查找树

> 判断给定序列是不是对应一个二叉查找树的后序遍历序列（数字两两不同）

#### 中序+后序

+ 因为BST中序遍历结果为升序序列，因此可根据后序序列得到中序序列

+ 后序序列最右侧为根，中序划分左右子树元素个数，后序序列左侧为左子树，右侧为右子树，递归执行

该方法可**建立/判断**

#### 后序+大小判断

如果不需要建树，只需判断的话，可以省去中序，直接用后序的左子树小于根，右子树大于根的特性进行递归判断

+ 从左到右找到第一个大于根的值，其下标为左子树长度；
+ 接着向后若找到一个小于根的值，表明不可能；否则递归判断左右子树是否为BST

仅可用于**判断**

### 二维数组中的查找

> 给定一个n*m的二维数组，每一行从左到右递增，每一列从上到下递减。给定一个数，判断是否存在？

+ 暴力遍历：直接遍历二维数组，复杂度为O(n*m)

+ **二分查找**：利用每行/每列有序特征，比如对于每一行，进行二叉查找，时间复杂度为O(n*logm)
+ **逆向思维**：不从左上角开始，而从**左下角/右上角**开始遍历。比如右上角可以完全确定其左侧比它小，下侧比他大，每走一步均可排除一行/一列，时间复杂度O(n+m)

以上两题均可利用二分查找特性

### 数组合并-尾插逆序

> 给定字符串，将空格替换为 %20，求扩展后的字符串

+ 若可开辟空间，则一次遍历即可完成，O(n)
+ 若不可开辟空间，需在原串做文章
  + 若从头开始遍历，有些字符有重复被向后移动，时间复杂度O(n^2)
  + 若**从尾开始遍历**，可先遍历字符串统计空格个数，计算出扩展后的字符串长度，定义pi，pj分别指向原串和扩展串末尾字符，若pi非空格，则直接插入pj中；否则插入`%20`。O(n)

#### **类似问题**

> 给定同为升序/降序数组A,B，合并AB后依然有序（假设A尾部有足够空间容纳B）

从尾部开始合并，计算A+B总长得到合并后的末尾，与上文思路一致，设立两个尾指针，依次比较即可

#### 总结

> 在不许开辟空间的情况下合并/扩展两个数组，从头开始可能导致大量重复移动，可考虑从尾部开始

### 栈队列互摸拟

> 用两个栈模拟队列

+ 遇到入队命令时，将元素压入栈s1；
+ 遇到出队命令时
  + 若栈s2为空，将栈s1中的元素依次弹出并压入栈s2，输出s2栈顶
  + 若栈s2非空，直接输出s2栈顶

> 两个队列模拟栈？（一个队列足矣！）

+ 遇到压栈命令，直接将元素入队
+ 遇到出栈命令，假设队列q长度为n，将q的前n-1个元素依次出队后重新入队。此时队首出队并输出

### 二叉树子结构

> 给定两个二叉树A和B，判断B是否为A的子结构（不是子树）
>
> 递归模拟判断：令bool f(A,B)表示B是否为A的子结构

```cpp
bool f(A,B) {
    bool ret=false;
	if (A != NULL && B != NULL) {
        if (A->val == B->val) ret = f2(A,B);
        if(!ret) ret = f(A->left,B);
        if(!ret) ret = f(A->right,B);
    }
    return ret;
}
bool f2(A,B) {
    if (B == NULL) return true; // 子结构判断；条件改为B==NULL&&A==NULL则判断子树
    if (A == NULL || A->val != B->val) return false;
    return f2(A->left,B->left) && f2(A->right,B->right);
}
```

### 出现次数大于一半的数

> 假设数组中存在出现次数大于一半的数，求出该数

+ partition：基于快速排序的partition，找到主元位于第n/2个位置的值，O(N)
+ 增减相消：设置两个变量，一个记录元素，一个记录该元素出现次数。若当前元素等于之前记录元素，则次数+1，否则更新记录元素为当前元素，且次数置1。最后保留的数必定为目标数，O(n)

### 找出最小的k个数

+ partition：O(N)，但不保证最小k个数有序（仅保证是正确的集合）
+ 红黑树（multiset/优先队列）：定义一个multiset，枚举每一个元素，若集合大小小于k，直接插入元素；若集合最大值小于当前元素，则删除最大值，插入当前元素。O(NlogK)

|           | 改变数组 | 时间复杂度 | 处理海量数据？     |
| --------- | -------- | ---------- | ------------------ |
| partition | 是       | O(N)       | 否                 |
| 红黑树    | 否       | O(NlogK)   | 能（多次部分读入） |

### 两个链表的第一个公共节点

> 给定两个单向链表，求二者第一个公共节点

+ 暴力：枚举链表1每个结点时，遍历链表2是否存在相同点，O(n^2)
+ 栈优化：开辟两个栈，分别遍历两个链表，将其从头依次压入。两个栈同时弹出栈顶，第一个不同的结点即为答案，时间/空间复杂度O(m+n)
+ 空间优化：遍历两个链表，求出二者长度差d。遍历二者时，长的链表走d步，再同时遍历两个链表，第一个相同的即为答案。时间复杂度O(m+n)，空间复杂度O(1)

> 将其逆时针旋转90即为树的最低公共祖先问题

#### 树的最低公共祖先

> 给定一棵树，两个结点，求出两个结点的最近公共祖先结点

+ 有指向父结点指针嘛？有的话直接转换为两个链表的第一个公共节点问题
+ 二叉树？BST？：若是，从根开始遍历每个结点，若当前结点大于两个指定结点，遍历左子树；若当前结点小于两个指定结点，遍历右子树；否则当前结点即为答案
+ 普通树，无指向父结点指针
  + 思路1：用f(root)=0,1,2分别表示以root为根的子树所包含指定结点的个数。若f(root)=2，且root孩子结点中不存在f(root->child)=2，则root为答案。
  + 思路2：记录从根到达两个指定结点的路径，转换为两个链表的第一个公共结点问题

### 二叉树深度

+ dfs遍历路径，保留最大值
+ 递归处理：当前深度=max(左子树深度,右子树深度)+1 =》**AVL判定**

### 层次遍历

> 1、直接按层次遍历输出节点

+ 一个队列即可实现。若是图，需增加访问数组vis标记点是否被访问；若是单向树，则不用。

> 2、分层打印结点

+ 二维数组+dfs：先序遍历过程中记录根据当前节点所在层次加入对应的数组尾部。

+ 两个队列：一个存放当前层，一个存下一层。
+ 一个队列
  + 标记法：在一层末尾添加定界标记，比如null。
  + 长度控制：每个队列出队前，队列长度为当前层的长度。

> 3、蛇形打印结点，即每层按正反向打印结点

+ 分层打印+数组反转：用数组保存每一层，奇数层正向输出，偶数层逆向输出。T(n)=O(n)，但需要开辟额外数组存储每一层。
+ 分层打印+双端队列：头取尾存（左子树-右子树），尾存头取（右子树-左子树）。仅需一个deque即可实现分层蛇形输出。

### 链表相关

> 1、给定**两个递增**的链表，求合并后的递增链表。不允许新建结点。（直接合并）
>
> 2、给定**两个递增且无重复**的链表，求合并后递增且无重复的链表。不允许新建结点。（去重合并）
>
> 3、合并**K个递增的链表**为一个递增链表，不考虑重复元素。假设总共有N个元素。
>
> + 数组暴力法：将每个链表元素转为数组，快速排序后，在存入链表
> + 遍历取最值：每次从K个值从选出最小值，T(N)=O(K*N)
> + 优先队列优化：用优先队列选择最小值，T(N)=O(N*logK)
> + 分治法：两两合并链表得到K/2个新链表，再两两合并K/2个新链表，得到K/4个新链表，以此类推，直至仅有1个链表。T(N)=O(N*logK)

## 语言特性

### sizeof

> sizeof用来测量当前变量所占字节数

+ 指针为4字节
+ 数组虽然本质也是指针，但是**sizeof结果为数组大小**（但数组作为参数传递时为指针；字符串为特殊数组）
+ 字符串常量维护在一个内存块中，但**赋值给数组时，会发生拷贝**；而赋给指针仅仅是地址

### vector

> stl动态数组
>
> 当空间满了后会申请比现在大一倍的空间，拷贝数据，释放原有空间
>
> 虽然好用，需注意效率，避免频繁改变空间大小

## 奇技淫巧

### 双指针

+ 数组：左右指针
+ 链表：快慢指针

#### 左右指针

> 二分查找
>
> 滑动窗口：解决字符串匹配问题
>
> 两数之和：高效处理有序的数组
>
> 反转数组

##### 调整数组顺序使奇数位于偶数前（n元划分）

> 给定一个数组，调整元素顺序，令所有奇数在所有偶数前面

定义左右指针pl和pr，左指针只可向右移动，右指针只可向左移动，二者分别指向左侧第一个偶数，右侧第一个奇数，交换pl和pr指向内容，直至pl>=pr时停止循环

> 扩展问题
>
> 被3整数的放在前，其余放在后
>
> 2元划分问题--n元划分（分解为多个2元划分）
>
> 框架逻辑不变，仅需传入一个函数指针参数，作为条件判断，即可完成扩展

#### 快慢指针

+ **找指定位置（长度未知）**

> **1、给定单向链表，求k等分点（中点为2等分）**
>
> 算法：每走一步，慢指针slow移动1个长度，快指针fast移动k个长度，当fast到终点时停止，slow即为最左侧的k等分点

> **2、给定单向链表，求倒数第k个点**
>
> + 二次遍历：第一次遍历计算出链表长度n，第二次遍历找到第n-k+1个点
> + 一次遍历：快指针先移动到第k个点，之后每走一步，慢指针和快指针均移动一个长度，直至快指针到终点，slow即为倒数第k个点
>
> 本质来说二者访问节点次数均为2n-k，好像无差异？？？

+ **链表环**

> **1、给定链表，判断是否存在环**
>
> 与k等分点思路类似，只要令快指针每步移动长度大于慢指针，若快指针遇见NULL，说明不存在环；若快慢指针相遇，表示存在环
>
> **2、给定带环链表，求环入口**
>
> 假设每走一步，慢指针移动1个长度，快指针移动2个长度。
>
> + 二者开始移动，直至第一次相遇
> + 将慢指针重新指向头结点，快指针保持在相遇点，二者继续移动，再次相遇处即为环入口（就算快指针超过慢指针多圈，二者也依旧满足该关系）

### 二分查找

#### 旋转数组的最小元素

> 将一个数组的前m个元素移到数组末尾，形成旋转数组。给定递增数组的旋转数组，求最小元素。
>
> 如[4,5,1,2,3]是[1,2,3,4,5]的旋转数组，最小值为1

+ 直接遍历：一次遍历找最小值，O(n)
+ 二分查询：利用该旋转数组是两段递增数列，采用二分查找。O(logn)
  + 若当前数大于等于首元素，说明其在第一个递增序列，左指针右移
  + 若当前数小于等于尾元素，说明其在第二个递增序列，右指针左移

**二分查找存在一定缺陷**

+ 缺陷1：若旋转数组为原来的递增数组，则第一个元素就是最小值
+ 缺陷2：若**左指针，中指针，右指针所指元素相同**，无法判断中点位于哪个序列，只能顺序查找（反例：10111,11101）

### 位运算

#### 二进制中1的个数

> 给定一个整数a，求其二进制表示中1的个数

+ a右移：a每次右移1位，记录最低位为1的次数

存在bug，a为负数时陷入死循环

+ 1左移：1每次左移1位，记录和a与的非零结果个数
+ 优化：`a&(a-1)`，**每次将a最右侧1置零**，最快的方式

> 相关题
>
> 1、求给定整数是否为2的整数倍？
>
> 用**a&(a-1)**判断a二进制是否仅存在一个1
>
> 2、求整数a至少要改变多少位才能变成整数b？
>
> 将c=a^b，c中1的个数即a和b不同的个数（还是**c&(c-1)**)

#### 数组中只出现一次的数

> 输入一个数组，除了2个数外，其余均出现2次，请找出2个出现一次的数。时间复杂度O(n)，空间复杂度O(1)

**1、异或运算**

简化分析，考虑只有一个数出现一次，由于空间复杂度限制，引导我们必须利用数字的某种特征规律，尝试使用加减法，因为加上a和减去a可以消除成对的数，剩余的即为出现一次的数，但有个问题，怎么判断何时加何时减？

于是放弃，采用完全加再除以2，也是不行，加减乘除都走不通，此时**异或运算**出现了，两个相同的数异或值必定为0，因此实现了最初的思路。

**2、逻辑分组**

那么如何处理2个出现一次的数呢？若直接异或后得到的结果必定为一个非0值，但是无法逆推出运算前的两个数。

**是否可以利用分解的思想？将该问题转换为一个数出现一次？**

答案是肯定的，不过需要一点想象力：假设第一次所有数异或得到的结果为a，那么找到a的二进制表示中最右侧的1的位置pos，通过二进制的pos位为0或1将所有数划分为两组，理由如下：

	1、首先pos为1，说明两个进行运算的原数必定在该位不同，因此可区分二者
	2、由于其余数均成对，所以成对的数必定会分在同一组

这样即可通过一次遍历计算两个分组的异或值。

### 模拟

#### 打印1到最大的n位数

> 依次打印1到最大的n位数。例如n=3，打印1,2,3,...,999

+ 字符串模拟：由于并未指明n的取值范围，需考虑大整数模拟运算。即用字符串实现加法，并且打印字符串（注意0不打印）
+ 全排列模拟：0~9的一个n位排列模拟

#### O(1)时间删除链表指定结点

> 给定一个单向链表的头指针和要删除的结点指针，要求在O(1)时间内删除结点
>
> **前提假设：链表中存在删除的点**

+ 从头遍历：常规思路从头开始遍历，找到要删除结点的前一个结点指针pre，然后将pre指向pcur->next
+ 覆盖删除：直接将pcur后面的结点覆盖当前结点，然后从当前结点断开与后续结点的连接。存在特例，当前结点为尾结点时，只能从头遍历。若链表仅有一个结点，注意赋值head为NULL。总体时间复杂度`O(((n-1)*1+1\*n)/n)=O(1)`

### 动态规划

#### 斐波那契数列

+ 递归实现，效率太低-->dp思想，用两个滚动变量迭代（避免重复计算子问题）

>  **相关问题**

> 1、青蛙一次可跳1或2层台阶，问n层台阶有多少种跳法？
>
> $$dp[n]=dp[n-2]+dp[n-1]\\dp[1]=1\\dp[2]=2$$

> 2、青蛙一次可跳1、2、3、...、n层台阶，问n层有多少种跳法？
>
> $$ dp[n]=dp[n-1]+dp[n-2]+...+dp[0] \\ dp[0]=1\\dp[1]=1\\dp[2]=2 $$
>
> 数学归纳法可证：$$dp[n]=2^{n-1}$$

> 3、用2*1的矩形去填充2\*8的矩形，问有多少可能？
>
> **dp[i]表示填充2*i的矩形的方法数**
>
> $$dp[n]=dp[n-1]+dp[n-2]$$

#### 连续子数组的最大和

使用动态规划求解

dp(i)表示以第i个元素结尾的最大连续子数组和，得到递推公式如下

$$dp(n) =
\begin{cases} 
0,  & n=0 \\
max(dp[n-1]+A[n],A[n]), & n>0
\end{cases}$$

直观意义为若A[n]加上1个值反而比自身小，说明加上的这个值对自身无意义，对之后的和也是无意义的，所以干脆只保留自身（自立门户）；否则，攀高枝

### 数学规律

#### 把数组排成最小的数

> 输入一个正整数数组，把数组中所有数连接起来排成一个数，打印其中最小的值。

+ 暴力枚举：枚举全排列，复杂度n！
+ 排序优化：制定一个排序规则，排好序后即为答案，O(nlogn)

规则：假设存在两个正整数a，b，比较ab和ba的字典序，小者的组合方式即对应的先后方式，如ab<ba，那么a<b（a在b前）

> 数学证明：
>
> 1、a < b具有自反性，对称性，传递性
>
> 2、反证法
>
> 假设排好序后的A1...Ax...Ay...An可以通过交换Ax和Ay达到更优，即A1...Ay...Ax...An<A1...Ax...Ay...An。
>
> 从A1...Ax...Ay...An开始，不断前移Ay直到Ax在Ay后，即A1...Ax...Ay...An<A1...AyAx...Ay-1...An
>
> 从A1...AyAx...Ay-1...An开始，不断前移Ax直到Ay-1在其前面，即A1...AyAx...Ay-1...An<A1...AyAx-1...Ay-1Ax...An，与假设矛盾

#### 丑数

> 只含有因子2、3、5的整数称作丑数。1默认为第一个丑数，求出第m个丑数。

+ 暴力枚举：从1开始，依次判断每个整数是否为丑数，直到找出m个丑数停止
+ 构造法：暴力枚举对许多非丑数进行判断，从而浪费了时间。利用构造的方式，即从1开始，每个数都可用×2，×3，×5的方式构造出来，关键在于如何保证其有序性。假设数组R为目前已经有序的丑数序列
  + 朴素想法：将R中所有值均\*2，\*3，*5，找出其中恰好大于R中最大值（末尾元素）的元素，依次类推，直至找到m个
  + 优化：对于数组R，存在一个元素T，T之前的元素\*2均小于R最大值，从T开始的元素\*2均大于R最大值，因此T为临界值。对于3,5同样存在T3,T5，下一个丑数即为三者运算的最小值`min(T2*2,T3*3,T5*5)`

## 排序

> https://www.cnblogs.com/onepixel/articles/7674659.html

