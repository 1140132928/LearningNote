# 概述

## 目标定义

为什么要有OS？目标：

+ 屏蔽底层细节，软硬件管理，提高生产力
+ 好用
+ 提高资源利用率

定义：

+ 软硬件资源管理；工作流程组织
+ 提高资源利用率
+ 便于用户使用的程序集合

![1585623607941](OS-Note.assets/1585623607941.png)



## 发展过程

+ 发展初期：无OS，手工操作阶段

+ 第二阶段（50年代）：早期批处理系统（**单道批处**理）

+ 第三阶段（60年代）：（真正意义上的OS）

  + **多道批处理**：内存中同时存放多个已开始运行的程序
    + 特点
      + 并发性（并发-**一段时间**；并行-**同一时刻**）
      + 无序性
      + 调度性
    + 优点：大型科学计算，数据处理（吞吐量大，资源利用率高）
    + 缺点：**无交互**
  + **分时系统**：**时间片分配**，服务多个用户，保证响应时间，支持会话
    + 过长：响应时间长
    + 过短：资源利用率小（调度程序要cpu时间）
  + **实时系统**：在**规定时间**内完成处理（**高可靠，安全，完整**）
    + 实时控制系统：军工国防
    + 实时消息处理系统：银行，股票，支付宝

+ 第四阶段：进一步发展

  + 微机应用：MS DOS，Windows，Unix，Linux
  + 随计算机系统结构而发展的OS，出现并行机OS，网络OS，分布式OS
  + 嵌入式OS：Vxworks

  ![1585812295390](OS-Note.assets/1585812295390.png)

## 四个特征(考)

并发和共享是相辅相成的两个特点，无并发就无共享，更好的共享可促进并发。

+ **并发**：并发（**一段时间**内），并行（**同一时刻**）
+ **共享**：资源共享
  + **互斥**共享：**一段时间**仅**一个**进程使用（打印机）
  + **同时**访问：**一段时间**可**多个**进程访问（磁盘，访问码）
+ 虚拟：**一个物理实体**分为**多个逻辑实体**（资源虚拟-功能扩展）
  + 多道程序设计：cpu虚拟
  + 虚拟内存：内存虚拟
  + Spooling技术：I/O设备虚拟
+ 不确定性（异步性）：过程不确定，环境相同时，结果必确定

![1585809360865](OS-Note.assets/1585809360865.png)

## 五大功能

+ 处理机管理：处理机的**分配运行**，本质为**进程管理**
  + 进程控制：建立，分配资源，运行，回收资源，撤销
  + 进程同步：进程协调
  + 进程通信
  + 进程调度
+ 存储器管理
  + 内存分配：分配，回收，移动
  + 内存保护
  + 地址映射
  + 内存扩充
+ 设备管理
  + 任务
    + 为用户程序分配I/O设备
    + 处理用户请求的I/O操作
    + 提高I/O设备利用率
  + 缓冲管理：缓和cpu和IO设备速度不匹配矛盾
  + 设备管理：分配设备
  + 虚拟设备
+ 文件管理
  + 存储空间
  + 目录管理
  + 文件读写
+ 用户接口
  + 命令接口：cmd中的命令（终端）
  + 程序接口：系统调用
  + 图像接口：

### 结构设计

+ OS构件：**内核**，进程，线程，管程
+ 内核
  + 单内核：各部件混居（unix/linux，window）（如今主体）
  + 微内核：结构性与功能性部件分离（学术，效率低）
  + 混合内核：折中单微内核，较多组件在核心态中运行
  + 外内核：减少软件抽象和消息传递机制，专注于硬件抽象（部分嵌入式使用）
+ 设计思想：模块化，层次式，虚拟化

### 内核实现--层次式结构

# 进程管理

> 计算机如何快速判断两条语句可并发执行？

计算出读集，写集，当两个程序不同时读时，它们集合为空

![1586412218648](OS-Note.assets/1586412218648.png)

## 基本概念

### 定义（三句话）

+ 进程是程序的一次**执行**。
+ 进程是程序在数据集合上的运行过程，是资源分配和调度的基本单位。
+ 程序及数据在处理机上的顺序执行所发生的活动。

### 5特征（进程vs程序--考）

+ 动态性：程序的一次执行过程是进程（过程性）
+ 并发性
+ 独立性：资源分配，调度的基本单位（资源+任务）
+ 异步性：何时执行不知道
+ 结构特征：Unix的进程映像=**程序段+数据段+进程控制块**

### 3状态

+ 就绪态Ready：仅缺少CPU资源，一旦获得CPU时间，立即执行。就绪队列。
+ 运行态Running：已获得CPU时间，正在执行。
+ 阻塞/等待/睡眠Block：等待某事件而暂停，如等待IO操作结束，等待通信，等待申请缓存空间。分级阻塞队列。
+ **一句话总结：万事俱备-Running；仅缺CPU--Ready；缺少CPU+其它资源--Block**
+ 挂起状态：资源吃紧，负荷较重，资源查看时将一些进程挂起，处于静止状态，即无视状态转换

3状态转换图

+ 为何Ready不可转换为Block？
  + 只有跑起来才能知道缺什么（Ready没有检测缺少什么资源，比如开始就直接加入就绪队列）

### 进程控制块PCB

管理进程的数据结构，包含进程的所有信息。

PCB是系统感知进程的唯一标志。

#### 组成结构

+ 标识：外部（用户标记），内部
+ 处理机状态：寄存器，栈指针，PSW，指令计数器
+ 进程调度信息：进程状态，优先级，事件（需要的资源），其它信息
+ 进程控制信息：程序和数据地址；同步和通信；资源清单（需要的资源和已有资源）

#### 组织方式

**时间，空间，稳定性**三个角度比较

+ **链接**：增删多，查找慢，内存节约，不稳定（电磁环境下一个断开后面都找不到）
+ **索引**：较稳定，查找快，内存浪费（索引表--空间换时间）

## 进程控制

> 内核：提供核心常用功能，使用原语操作实现
>
> 原语操作：原子操作，即操作集合要么同时执行，要么都不执行。（关中断，执行，开中断）

创建进程的事件：

+ 用户登录
+ 作业调度
+ 提供服务
+ 应用请求

创建步骤：

+ 申请PCB
+ 分配资源
+ 初始化PCB
+ 加入就绪队列

结束条件：

+ 正常结束
+ 异常
  + 越界溢出
  + 保护错：无权限访问某个资源或文件
  + 特权指令错：用户执行仅允许OS执行的指令
  + 非法指令错：执行不存在的指令，电磁干扰导致eip错误
+ 外界干预

结束步骤：

+ 释放资源
+ 销毁PCB

## 进程同步（考重点）

任务：进程间共享资源和合作

生产者-消费者问题：counter+1和counter-1可拆成3句机器语言

临界资源：一次仅允许一个进程访问

临界区：包含访问临界资源的代码块

**进程同步4特征（评价标准）：**

+ 基本要求
  + 空闲让进：临界区无进程，可允许进程进入
  + 忙则等待：临界区有进程，不允许其它进程进入
+ 优化要求
  + 有限等待：进程等待进入临界区时间有限，避免“死等”
  + 让权等待：进程等待进入临界区时，交出cpu资源，避免“忙等"(一直占用cpu等待，效率低)

同步控制尝试

#### **软件控制**

+ 增加开关变量turn，两个进程交替进行；满足基本要求，但是会死等。
+ 增加全局共享变量flag[2]，给门上锁，先判断对方状态，再改变自身状态。有问题-可能两个进程同时访问临界资源。
+ 增加全局共享变量flag[2]，给门上锁，先改变自身状态，再判断对方状态。有问题-可能两个进程死锁（都进不去）。

**硬件控制**

+ 关中断：关中断-测试锁-（锁开则关锁）-开中断。
+ 硬件指令Test-and-Set：测试并建立指令是一个原语，执行具有不可分割性（可看成一个不可打断的函数）。

**信号量**

+ 整型信号量

以上所有的同步实现方式均存在一个问题：**忙等**

+ **记录型信号量（考**）

解决问题：通过增加阻塞队列，实现**主动让权**，**避免忙等**

定义一个信号量结构体，以及最简单的两个操作：申请和释放资源

应用场景：多个并发进程共享**一个资源**

```cpp
struct Semaphore { // 信号量结构体
	int value; // >0：表示可用资源个数；<0：绝对值表示阻塞进程的个数
    struct process_control_block* list; // 阻塞的进程链表
};
Semaphore s; // 初始化，若val初值为1，则是互斥访问变量，实现进程互斥访问
void wait(Semaphore* s) { // 申请资源操作，简写成P也行（PV是荷兰语）
	s->value--;
    if (s->value<0) block(s->list); // 资源不足，进程主动加入等待/阻塞队列 
}
void signal(Semaphore* s) { // 释放资源操作，简写成V也行
    s->value ++;
    if (s->value<=0) wakeup(s->list); // 唤醒阻塞队列第一个进程
}
```

+ AND信号量：共享多个资源。避免死锁（用简单信号量连续申请多次则会导致死锁）

+ 信号量集：每个资源每次可以+/-d；资源低于某下限就不再分配

  Swait阻塞后需要被唤醒时需要重新执行swait（普通wait可以直接继续执行）。因为共享多个资源，需重新判断是否全部满足。

  Ssignal释放后，将所有有关的进程唤醒加入ready队列（普通signal只唤醒第一个）。因为共享多个资源，不一定第一个就会满足，因此遍历所有，分配给有可能全部资源都满足的进程。

功能：互斥，前驱，同步问题

PV解决生产者和消费者问题：

+ 互斥：互斥变量mutex
+ 自身特性：缓冲区未满生产者可生产，缓冲区非空消费者可取用
+ P互换位置会导致死锁；V互换不会死锁，但是效率低下

```cpp
item buf[N]; // 缓冲池大小（N个缓冲区）
int in=0, out=0; // 指示生产者存放物品和消费者取物品的缓冲区下标（循环数组模拟）
semaphore mutex=0; // 互斥变量，0表示临界区无人，不可进入；1表示临界区有人，可以进入
semaphore empty=N,full=0; // empty表示空缓冲区个数；full表示满的缓冲区个数（假设一个缓冲区存一个物品）
void producer() { // 生产者
	while (true) {
        // P(mutex)若在P(empty)前，在全空和全满情况下，会发生死锁
        P(empty); // 申请空缓冲区资源，申请失败则Block
        P(mutex); // 申请互斥访问；mutex=0则可以继续访问
        // 临界区
        buf[in] = 生成的物品
        in = (in+1)%N; // 后移
        // PV必成对出现
        V(mutex); // 释放互斥访问变量，置mutex=0
        V(full); // 释放full资源，表示满缓冲区多1个
    }
}
void consumer() { // 消费者
	while (true) {
        P(full); // 申请满缓冲区资源，申请失败则Block
        P(mutex);
        // 临界区
        取出buf[out];
        out = (out+1)%N;
        V(mutex);
        V(empty); // 释放empty资源，表示空缓冲区多1个
    }
}
void main() {
	producer();
    consumer();
}
```

and信号量解决生产者-消费者问题

```cpp

```

哲学家进餐

```cpp
pi表示进程，S[i],S[(i+1)%n]
// 互斥访问S[i]，mutex[i]
void producer() {

}
```

读者-写者问题

+ 可同时读
+ 不可同时读写
+ 不可同时写

```cpp
// 写-互斥mutex
// 读-不用互斥，记录可用最大变量S
P(mutex)
P(S)
V(mutex)
    
P(mutex)
P(S)
V(S)
V(mutex)
```

第一个读需要加锁，最后一个离开需解锁；读写共用一把锁

## 管程机制

过桥问题：南北方向有座独木桥，桥上同一方向最多容纳N个人，两侧人群如何过桥？

类似读者-写者问题，两侧均变成读者。

```cpp
// 错误案例：第一次执行P1后，if（count==1）前出现中断，再执行一次P1，导致if条件失效
wmutex = 1
count = 0
rmutex = 1
p1 {
	p(rmutex);
	count++;
	v(rmutex);
    
	if(count == 1) p(wmutex);
	
    done();
	
    p(rmutex);
	count--;
	v(rmutex);
	
    if(count == 0) v(wmutex);
}
// 正确参考1
NtoS = 1, StoN = 1, bridge = 1;
int NtoS_count = 0, StoN_count = 0;
void northToSouth(){
	wait(NtoS);
	if(NtoS_count == 0) wait(bridge);
	NtoS_count++;
	signal(NtoS);
	过桥
	wait(NtoS);
	NtoS_count--;
	if(NtoS_count == 0) signal(bridge);
	signal(NtoS);
}
void southToNorth(){
	wait(StoN);
	if(StoN_count == 0) wait(bridge);
	StoN_count++;
	signal(StoN);
	过桥
	wait(StoN);
	StoN_count--;
	if(StoN_count-- == 0) signal(bridge);
	signal(StoN);
}
// 正确参考2：待证明？
south=1;//南方向信号量 
north=1;//北方向信号量 
mutex=1;//桥 
count_south=0;//从北往南的人数 
count_north=0;//从南往北的人数 
north_to_south(){
	P(south);
	count_north++;
	if(count_north==1){
		P(mutex);
	}
	V(south);
    
	过桥；
	
    P(south);
	count_north--;
	if(count_north==0){
		v(mutex);
	} 
	V(south);
}
```

考试写标准写法

一家四口橘子和苹果问题：母亲买橘子，女儿吃橘子；父亲买苹果，儿子吃苹果，仅一张桌子，一次仅放一个水果。

```cpp
// 错误案例
pmutex=1, cmutex=1; // 父母，孩子互斥访问果盘变量
isEmpty=1; // 果盘是否为空
fruitType=1; // 果盘水果类型:1苹果，2橘子
father() {
    P(pmutex);
    if (isEmpty == 1) fruitType = 1;
    V(pmutex);
}
son() {
    P(cmutex);
    if (isEmpty==0 && fruitType==1) isEmpty=1;
    V(cmutex);
}
// 正确参考：信号量，定义，初值，循环，写全
Semophere empty=1,fullA=0,fullO=0; // 信号量类型+初值！！！
Semophere mutex=1;
father() {
    while (true) { // 循环！！！
        P(empty);
        p(mutex);
        放苹果
        V(mutex);
        V(fullA);
    }
}
son() {
    while (true) {
        P(fullA);
        P(mutex);
        拿苹果
        V(mutex);
        V(empty);
    }
}
mother() {
    while (true) {
        P(empty);
        P(mutex);
        放橘子
        V(mutex);
        V(fullO);
    }
}
daughter() {
	while (true) {
        P(fullO);
        P(mutex);
        那橘子
        V(mutex);
        V(empty);
    }
}

```



## 进程通信

共享存储器系统

+ 共享数据结构
+ 共享存储区

消息传递系统

+ 直接通信：A直接给B
+ 间接通信：A给C，C给B。信箱缓冲

管道：读写进程共享Pipe文件，常用与Unix。互斥和同步问题。

send和receive原语

定长和变长消息：各有优劣（开销vs处理）

> 如果消息缓冲队列里消息个数最多为L，如何改写通信机制？

**本质是生产者-消费者问题，即长度最大为L的缓冲区**（代码稍微改改就行）。send在wait(mutex)前增加wait(empty)，receive在signal(mutex)后增加signal(empty)

```cpp
Semaphore empty=L; // 消息队列有剩余的空间；类似P-S中的empty变量
Semaphore mutex=1; // 互斥访问消息缓冲队列
Semaphore sm=0; // 消息缓冲队列中已有的大小（可用资源量）类似P-S中的full变量

// 发送者代码；先申请足够大的消息缓冲区，然后将首地址为a的消息发送区拷贝于消息缓冲区；获取接受者的标识，插入其消息队列中。
// receiver-接受者进程标识符，a：发送区首地址
send(receiver, a) {
    getbuff(a.size,i); // 申请a.size大小的缓冲区，存于i
    // 将三个属性拷贝到消息缓冲区i中
    i.sender = a.sender;
    i.size = a.size;
    i.text = a.text; // 应该有消息内容的拷贝的，可省略
    i.next = 0; // 看成队尾
    // 从PCB集合中，根据receiver获得接受进程的标识符j
    getid(PCBset, receiver, j);
    // 消息队列长度上限为L，转换为生产者-消费者问题，仅需增加下面一句
    // 注意和互斥变量不可交换先后位置，否则在全满/全空情况下导致死锁
    wait(empty); // 消息队列有空位才能发送
    
    // 以下为原有的原语操作
    wait(j.mutex); // 互斥访问消息队列
    insert(j.mq,i); // 将缓冲区i插入j的消息缓冲队列
    signal(j.mutex); // 释放互斥变量
    signal(j.sm); // 消息缓冲队列大小+1（可用资源+1）
}
// 接受者代码；摘下消息队列的第一个缓冲区i，并插入首地址为b的消息接收区
receiver(b) {
	j = internal name; // j为接收进程内部标识
	wait(j.sm); // 申请消息队列资源（-1）
	wait(j.mutex); // 互斥访问
	remove(j.mq, i); // 取下消息队列的第一个消息
	signal(j.mutex); // 释放互斥变量
    // 消息队列长度上限为L，转换为生产者-消费者问题，仅需增加下面一句
    signal(empty); // 释放空变量
    
	// 从i中拷贝有效信息到b
	b.sender=i.sender;
	b.size = i.size;
	b.text=i.text;
	
	releasebuf(i); // 释放消息缓冲区i
}
```

## 线程

资源分配依旧是进程，而线程是任务分配

特征

+ 调度：轻量级的任务调度单位，提高并发程度

+ 并发：进程并发，线程并发
+ 资源：无资源，共享其所在进程的资源
+ 开销
  + 创建和撤销：进程需要分配和回收系统资源，开销大；线程不带资源，比进程快。
  + 切换：进程需要保存很多内容，线程保存内容少。
  + 同步和通信：**同一进程的线程**有同一地址空间，通信简单。

分类：

+ 内核级线程：依赖内核，由内核创建，撤销，切换。靠线程控制块感知。
+ 用户级线程：不依赖于内核。

区别：

+ 调度：进行系统调用时，内核线程把线程为单位进行阻塞，仅该线程被阻塞；用户级线程被内核当成进程，该线程所在的整个进程被阻塞。
+ 线程执行时间：用户级的线程无法被内核感知，只会被当成一个进程。以进程/线程为单位进行分配，均不公平。

**线程资源**：局部变量，栈，状态字

**进程资源**：全局变量，打开的文件，子进程，地址空间

# 考试！信号量，定义，初值，循环，写全

# 处理机调度和死锁

调度本质是资源的分配

## 调度层次

| 类型\对比项目  | 对象            | 功能                                                         | 常见问题             | 用途                                               | 时间特点                       |
| -------------- | --------------- | ------------------------------------------------------------ | -------------------- | -------------------------------------------------- | ------------------------------ |
| 高级/长程/作业 | 作业            | 将外存后备队列的作业调入内存，创建进程，分配资源，放入就绪队列 | 一次调几个；调哪几个 | 多道批处理系统常见；分时和实时不用                 | 几分钟一次，可设计复杂调度算法 |
| 中级/中程/内存 | 进程/内存？     | 挂起状态：将某些进程调至外存，再适时调入内存                 |                      | 提高内存利用率和系统吞吐量。存储器管理中的对换功能 | 处于短程-长程之间              |
| 低级/短程/进程 | 进程/内核级线程 | 选择就绪队列中的进程，分配处理机                             | 抢占式/非抢占式      | 多道批处理，分时，实时均必备                       | 10~100ms一次，仅可用简单算法   |

+ 命名角度
  + 消耗时间：耗时最长的称长程，最短的称短程，介于二者之间的称中程调度。
  + 操作对象：作业，内存，进程
+ 存储结构
  + 外存有后备队列，挂起进程的存储；
  + 内存中有就绪队列，阻塞队列
+ 为何把进程和内核级线程作为短程调度对象？
  + 内核级线程可直接被内核直接感知；而用户级线程无法被内核感知，所以无法调度。



作业调度？进程调度？

## 调度算法评价

### 面向用户

+ **周转时间**：从提交给系统，到完成作业的时间
  + 等待时间
    + 外存后备队列等待
    + 就绪队列等待
    + 阻塞队列等待（等待IO事件）
    + 挂起到外存（**也算**）
+ CPU执行时间
  
+ 响应时间
+ 截止时间（必须开始的最迟时间，必须完成的最迟时间）

平均周转时间：$T=\cfrac{1}{n}\mathop{\Sigma}\limits_{i=1}^{n}T_i$，其中$T_i$为第i个作业/进程的周转时间。

加权周转时间：$T=\cfrac{1}{n}\mathop{\Sigma}\limits_{i=1}^{n}\cfrac{T_i}{T_s}$,其中$T_s$为第i个作业的实际执行时间（占用CPU的时间）。**增加用户体验**，公平一些。

### 面向系统

+ 系统吞吐量：单位时间完成的任务数
+ CPU利用率
+ 各类资源利用率：内存，外存， IO设备

## 调度算法

### 先来先服务

适用于作业，进程

实例演示：短作业C待遇明显不如长作业D

| 进程名 | 到达时间 | 服务时间 | 开始时间 | 结束时间（开始+服务） | 周转时间（结束-到达） | 带权周转时间（周转/服务） |
| ------ | -------- | -------- | -------- | --------------------- | --------------------- | ------------------------- |
| A      | 0        | 1        | 0        | 1                     | 1                     | 1                         |
| B      | 1        | 100      | 1        | 101                   | 100                   | 1                         |
| C      | 2        | 1        | 101      | 102                   | 100                   | 100                       |
| D      | 3        | 100      | 102      | 202                   | 199                   | 1.99                      |

+ 有利于长作业/进程；不利于短作业/进程

+ 有利于CPU繁忙；不利于I/O繁忙

### 短作业优先SJF

适用于作业，进程

计算实例

![1589253313404](OS-Note.assets/1589253313404.png)

优先级

静态：一开始确定，后续不变

动态：动态改变

### 高响应比优先调度

适用作业调度，融合长短调度
$$
优先级=\cfrac{等待时间+要求服务时间}{要求服务时间}
$$

+ 等待时间相同时，要求服务时间越小，优先级越高，即短作业优先（工作时间段优先）。
+ 要求服务时间相同时，等待时间越大，优先级越高，即先来先服务（等待时间长优先）。
+ 这里的优先级取值越大表示级别越高！它是动态优先级，随着等待时间的变化而变化

### 时间片轮转调度

按照FCFS将进程排序，确定一个时间片长度，执行队首，存在两种状态：

+ 时间片没用完，进程执行完毕，结束，调用下一个队首
+ 时间片用完，进程为执行完毕，插入就绪队列队尾

时间片选取值得考虑：

+ 时间片太长：退化为FCFS，响应时间长。
+ 时间片太短：退化成SJF，切换效率低，资源消耗大。

例题如下：

**注意开始时间为0，这时只有A到达**，有些题目会指明开始时间为0，但所有进程已达到。

以下为时间片取1s和4s的对比过程

|          | A    | B    | C    | D    | E    | 平均时间 |
| -------- | ---- | ---- | ---- | ---- | ---- | -------- |
| **到达时间** | **0** | **1** | **2** | **3** | **4** |          |
| **服务时间** | **4** | **3** | **4** | **2** | **4** |          |
| **时间片1s** ；0s第一轮 | 1 | 1 | 1 | 1 | 1 |          |
| 5s第二轮 | 1 | 1 | 1 | 1 | 1 |          |
| 10s第三轮 | 1 | 1 | 1 |      | 1 |          |
| 14s第四轮 | 1 |  | 1 |      | 1 |          |
| 周转时间（结束-开始） | 15-0=15 | 12-1=11 | 16-2=14 | 9-3=6 | 17-4=13 | 11.8 |
| 带权周转（周转/服务） | 15/4=3.75 | 11/3=3.67 | 14/4=3.5 | 6/2=3 | 13/4=3.25 | 3.434 |
| **时间片4s**；0s第一轮 | 4 | 3 | 4 | 2 | 4 |  |
| 周转时间（结束-开始） | 4-0=4 | 7-1=6 | 11-2=9 | 13-3=10 | 17-4=13 | 8.4 |
| 带权周转（周转/服务） | 4/4=1 | 6/3=2 | 9/4=2.25 | 10/2=5 | 13/4=3.25 | 2.7 |

可以看出，时间片取4s优于2s，周转时间短。

### 多级反馈队列

存在多个优先级递减的队列，优先级越高，对应时间片越长。队列内部按照FCFS排序。第i个队列队首时间片用完，但进程未执行完，则将其放入第i+1个队列尾部。满足各类需求。



> 给定一组作业J1,J2,...,Jn，它们的运行时间分别为T1,T2,...,Tn。假设它们同时到达，并在同一台处理机上单道按单道方式运行。试证明：按短作业优先调度，平均周转时间最短。

本质是**前缀和的累加和**

思路一：计算每个值的出现次数

假设按照J1,J2,...,Jn的顺序进行调度。

假设第i个进程被执行的结束时间为$T_i^{'}=\mathop{\Sigma} \limits_{j=1}^{i}T_i$

那么总的周转时间为：$T_{sum}=\mathop{\Sigma}_\limits{i=1}^{n}T_i^{'}=n\times T_1+(n-1)\times T_2+...+1\times T_n$

由展开式可知，按照作业运行时间的非降序顺序来计算可得到$T_{sum}$的最小值。



> 假设单处理机上有5个进程（1,2,3,4,5）争夺运行，运行时间分别为10,1,2,1,5秒，优先级分别为3,1,3，4,2（1最高），到达次序1，2,3,4,5（**开始时已全部到达**）。
>
> （1）用轮转法，SJF和**非剥夺优先权/非抢占式**调度法调度时的运行进度表。其中时间片取值为2。
>
> （2）给出上述算法调度下，每个进程的周转时间和等待时间。

+ **轮转法**：将进程按照FCFS排好序，放入队列。确定时间片长度。循环分配时间执行。

| 进程号                    | p1     | p2    | p3    | p4    | p5    |
| ------------------------- | ------ | ----- | ----- | ----- | ----- |
| **运行时间**              | **10** | **1** | **2** | **1** | **5** |
| 0s开始第一轮              | 2      | 1     | 2     | 1     | 2     |
| 8s开始第二轮              | 2      |       |       |       | 2     |
| 12s第三轮                 | 2      |       |       |       | 1     |
| 15s第四轮                 | 2      |       |       |       |       |
| 17s第五轮                 | 2      |       |       |       |       |
| **周转时间（结束-开始）** | 19     | 3     | 5     | 6     | 15    |
| **等待时间（周转-运行）** | 9      | 2     | 3     | 5     | 10    |

+ **短作业优先SJF**：时间短的优先被选择执行。时间一样短，选择先到的进程。

| 进程号       | p1      | p2     | p3     | p4     | p5     |
| ------------ | ------- | ------ | ------ | ------ | ------ |
| **运行时间** | **10**  | **1**  | **2**  | **1**  | **5**  |
| 结束时间     | 19（5） | 1（1） | 4（3） | 2（2） | 9（4） |
| 周转时间     | 19      | 1      | 4      | 2      | 9      |
| 等待时间     | 9       | 0      | 2      | 1      | 4      |

+ **非剥夺优先权/非抢占式**：优先级高者先执行，执行过程中不可被打断。

| 进程号              | p1     | p2    | p3    | p4    | p5    |
| ------------------- | ------ | ----- | ----- | ----- | ----- |
| **优先级（1最高）** | **3**  | **1** | **3** | **4** | **2** |
| **运行时间**        | **10** | **1** | **2** | **1** | **5** |
| 结束时间            | 16(3)  | 1(1)  | 18(4) | 19(5) | 6(2)  |
| 周转时间            | 16     | 1     | 18    | 19    | 6     |
| 等待时间            | 6      | 0     | 16    | 18    | 1     |