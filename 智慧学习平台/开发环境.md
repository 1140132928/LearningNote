## 开发环境

+ IDEA --java（软件管家破解版）
+ pycharm --python
+ Linux -- c/c++
+ mysql8 -- DB
+ redis  -- latest
+ Linux--CentOS7->docker->ubuntu14.04镜像->nginx+lua(dockerfile文件)



## tips

+ 安装CentOS7完成后，配置网络时使用NAT，设置勾选DHCP，自动分配子网ip

![1549205835510](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1549205835510.png)

需要了解一下ip,子网掩码，网关，http/https，tcp



+ 在centos7中安装docker

  1. 查看是否安装成功：`docker version`，出现两大段信息说明成功

  2. 启动：`systemctl start docker`

  3. 拉取镜像：`docker pull imgaesname`
  4. 运行镜像创建容器：`docker run --name [A] -it [imgaesname] /bin/bash`，[]内部为可替换内容
  5. 从容器中回到原来界面但不终止，`Ctrl + q + p`
  6. 查看状态：`docker ps`
  7. 退出：`exit`
  8. 杀死进程：``kill`

+ 利用docker容器`build`学长写好的`Dockerfile`，是先拉去`ubuntu:14.04`镜像，在镜像的实例容器安装`nginx+lua`模块。

## 1. 安装CentOS7

[安装教程]: https://mp.weixin.qq.com/s/0X1fq8xJjBQ5eKU8gQllWw



## 2. 安装docker

[安装教程]: http://www.runoob.com/docker/centos-docker-install.html

基本原理和操作参考**菜鸟教程**



## 3. 构建Dockerfile文件

该文件是docker脚本，构建时先拉取Ubuntu镜像，随后在Ubuntu环境中安装nginx和lua的集成模块

[参考构建教程]: https://blog.csdn.net/yinni11/article/details/81104397
[nginx入门参考]: https://blog.csdn.net/Melod_bc/article/details/53735426



### `Dockerfile`文件内容

```dockerfile
FROM ubuntu:14.04

ENV VER_NGINX_DEVEL_KIT=0.2.19
ENV VER_LUA_NGINX_MODULE=0.10.13
ENV VER_NGINX=1.13.6
ENV VER_LUAJIT=2.0.5

ENV NGINX_DEVEL_KIT ngx_devel_kit-${VER_NGINX_DEVEL_KIT}
ENV LUA_NGINX_MODULE lua-nginx-module-${VER_LUA_NGINX_MODULE}
ENV NGINX_ROOT=/nginx
ENV WEB_DIR ${NGINX_ROOT}/html

ENV LUAJIT_LIB /usr/local/lib
ENV LUAJIT_INC /usr/local/include/luajit-2.0

RUN apt-get -qq update
RUN apt-get -qq -y install wget
RUN apt-get -qq -y install make
RUN apt-get -qq -y install libpcre3
RUN apt-get -qq -y install libpcre3-dev
RUN apt-get -qq -y install zlib1g-dev
RUN apt-get -qq -y install libssl-dev
RUN apt-get -qq -y install gcc

RUN wget http://nginx.org/download/nginx-${VER_NGINX}.tar.gz
RUN wget http://luajit.org/download/LuaJIT-${VER_LUAJIT}.tar.gz
RUN wget https://github.com/simpl/ngx_devel_kit/archive/v${VER_NGINX_DEVEL_KIT}.tar.gz -O ${NGINX_DEVEL_KIT}.tar.gz
RUN wget https://github.com/openresty/lua-nginx-module/archive/v${VER_LUA_NGINX_MODULE}.tar.gz -O ${LUA_NGINX_MODULE}.tar.gz
RUN tar -xzvf nginx-${VER_NGINX}.tar.gz && rm nginx-${VER_NGINX}.tar.gz
RUN tar -xzvf LuaJIT-${VER_LUAJIT}.tar.gz && rm LuaJIT-${VER_LUAJIT}.tar.gz
RUN tar -xzvf ${NGINX_DEVEL_KIT}.tar.gz && rm ${NGINX_DEVEL_KIT}.tar.gz
RUN tar -xzvf ${LUA_NGINX_MODULE}.tar.gz && rm ${LUA_NGINX_MODULE}.tar.gz

WORKDIR /LuaJIT-${VER_LUAJIT}
RUN make
RUN make install
WORKDIR /nginx-${VER_NGINX}
RUN ./configure --prefix=${NGINX_ROOT} --with-ld-opt="-Wl,-rpath,${LUAJIT_LIB}" --add-module=/${NGINX_DEVEL_KIT} --add-module=/${LUA_NGINX_MODULE}
RUN make -j2
RUN make install
RUN ln -s ${NGINX_ROOT}/sbin/nginx /usr/local/sbin/nginx
WORKDIR ${WEB_DIR}
EXPOSE 80
EXPOSE 443

#RUN rm -rf /nginx-${VER_NGINX}
#RUN rm -rf /LuaJIT-${VER_LUAJIT}
#RUN rm -rf /${NGINX_DEVEL_KIT}
#RUN rm -rf /${LUA_NGINX_MODULE}

CMD ["nginx", "-g", "daemon off;"]
```

- 启动容器时，由于nginx在容器内部，其ip地址不同于宿主机（原本是win10），所以在虚拟机的浏览器测试可用`localhost`，而在宿主机（原本win10OS）中`localhost`不同于虚拟机中的，所以得先获取虚拟机docker的ip，再去宿主机测试
- 输入`ifconfig`，找到`ens33`（ens是确定的，数字在不同机器可能不同），`inet`对应的即是nginx对应的ip地址，如下图红框所示![1550589272908](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1550589272908.png)

+ nginx的基本操作参考**菜鸟教程**，测试时可在虚拟机火狐浏览器输入`localhost`或本地主机的任意浏览器输入得到的ip地址`192.168.142.134`（每次关机或重启后ip地址可能会改变，所以每次都获取下地址）

## 4. docker安装redis

[安装及基本操作参考]: http://www.runoob.com/docker/docker-install-redis.html

掌握启动，连接redis，存入键值对，获取键值对即可

## 5. 安装IDEA

[安装参考]: https://mp.weixin.qq.com/s/I7t4kpZS0PQY-mLEd7jAGw



## 6. 构建web应用并测试nginx的配置文件

使用IDEA构建web应用参考

### `nginx.conf`文件内容

(在不同机子上测试需要改动几处，随后再说)

```lua
events {
  worker_connections  1024;
}

http {
  lua_package_path "/nginx/lua/?.lua;;";
  server {
        listen       80;
        server_name  localhost;
        
location /test/ {
      set $temppp "";
      rewrite_by_lua '
        local headers = ngx.req.get_headers()
        local sessionID = headers["X-SmartStudy-SessionID"] --自己加入请求头
        if sessionID ~= ngx.null then
          local headerKey = "AuthPlatform_UserID"
          local begin, endindex = string.find(sessionID, "ADMIN", 1, true)
          if begin == 1 then
          	headerKey = "AuthPlatform_AdminID"
          else
            begin, endindex = string.find(sessionID, "TEACHER", 1, true)
            if begin == 1 then
              headerKey = "AuthPlatform_TeacherID"
            end
          end
          
        local redis = require "redis"
        local red = redis:new()
        red:set_timeout(400)
        local ok, err = red:connect("172.17.0.2", 6379)
--      ngx.say(red:get(sessionID))
        red:select(0)
--      ngx.say(red:get(sessionID))
	if ok then
            local userid, err = red:get(sessionID)
--                  ngx.say(headerKey)
              if userid ~= ngx.null then
--              ngx.say(userid)
                  ngx.req.set_header(headerKey, userid)
            end
          end
        end
      ';
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";
      proxy_pass http://192.168.101.8/;
    }
  }
}

```

### 依赖库文件`redis.lua`内容（直接用就行）

``` lua
-- Copyright (C) Yichun Zhang (agentzh)


local sub = string.sub
local byte = string.byte
local tcp = ngx.socket.tcp
local null = ngx.null
local type = type
local pairs = pairs
local unpack = unpack
local setmetatable = setmetatable
local tonumber = tonumber
local tostring = tostring
local rawget = rawget
local select = select
--local error = error


local ok, new_tab = pcall(require, "table.new")
if not ok or type(new_tab) ~= "function" then
    new_tab = function (narr, nrec) return {} end
end


local _M = new_tab(0, 54)

_M._VERSION = '0.27'


local common_cmds = {
    "get",      "set",          "mget",     "mset",
    "del",      "incr",         "decr",                 -- Strings
    "llen",     "lindex",       "lpop",     "lpush",
    "lrange",   "linsert",                              -- Lists
    "hexists",  "hget",         "hset",     "hmget",
    --[[ "hmset", ]]            "hdel",                 -- Hashes
    "smembers", "sismember",    "sadd",     "srem",
    "sdiff",    "sinter",       "sunion",               -- Sets
    "zrange",   "zrangebyscore", "zrank",   "zadd",
    "zrem",     "zincrby",                              -- Sorted Sets
    "auth",     "eval",         "expire",   "script",
    "sort"                                              -- Others
}


local sub_commands = {
    "subscribe", "psubscribe"
}


local unsub_commands = {
    "unsubscribe", "punsubscribe"
}


local mt = { __index = _M }


function _M.new(self)
    local sock, err = tcp()
    if not sock then
        return nil, err
    end
    return setmetatable({ _sock = sock, _subscribed = false }, mt)
end


function _M.set_timeout(self, timeout)
    local sock = rawget(self, "_sock")
    if not sock then
        return nil, "not initialized"
    end

    return sock:settimeout(timeout)
end


function _M.connect(self, ...)
    local sock = rawget(self, "_sock")
    if not sock then
        return nil, "not initialized"
    end

    self._subscribed = false

    return sock:connect(...)
end


function _M.set_keepalive(self, ...)
    local sock = rawget(self, "_sock")
    if not sock then
        return nil, "not initialized"
    end

    if rawget(self, "_subscribed") then
        return nil, "subscribed state"
    end

    return sock:setkeepalive(...)
end


function _M.get_reused_times(self)
    local sock = rawget(self, "_sock")
    if not sock then
        return nil, "not initialized"
    end

    return sock:getreusedtimes()
end


local function close(self)
    local sock = rawget(self, "_sock")
    if not sock then
        return nil, "not initialized"
    end

    return sock:close()
end
_M.close = close


local function _read_reply(self, sock)
    local line, err = sock:receive()
    if not line then
        if err == "timeout" and not rawget(self, "_subscribed") then
            sock:close()
        end
        return nil, err
    end

    local prefix = byte(line)

    if prefix == 36 then    -- char '$'
        -- print("bulk reply")

        local size = tonumber(sub(line, 2))
        if size < 0 then
            return null
        end

        local data, err = sock:receive(size)
        if not data then
            if err == "timeout" then
                sock:close()
            end
            return nil, err
        end

        local dummy, err = sock:receive(2) -- ignore CRLF
        if not dummy then
            return nil, err
        end

        return data

    elseif prefix == 43 then    -- char '+'
        -- print("status reply")

        return sub(line, 2)

    elseif prefix == 42 then -- char '*'
        local n = tonumber(sub(line, 2))

        -- print("multi-bulk reply: ", n)
        if n < 0 then
            return null
        end

        local vals = new_tab(n, 0)
        local nvals = 0
        for i = 1, n do
            local res, err = _read_reply(self, sock)
            if res then
                nvals = nvals + 1
                vals[nvals] = res

            elseif res == nil then
                return nil, err

            else
                -- be a valid redis error value
                nvals = nvals + 1
                vals[nvals] = {false, err}
            end
        end

        return vals

    elseif prefix == 58 then    -- char ':'
        -- print("integer reply")
        return tonumber(sub(line, 2))

    elseif prefix == 45 then    -- char '-'
        -- print("error reply: ", n)

        return false, sub(line, 2)

    else
        -- when `line` is an empty string, `prefix` will be equal to nil.
        return nil, "unknown prefix: \"" .. tostring(prefix) .. "\""
    end
end


local function _gen_req(args)
    local nargs = #args

    local req = new_tab(nargs * 5 + 1, 0)
    req[1] = "*" .. nargs .. "\r\n"
    local nbits = 2

    for i = 1, nargs do
        local arg = args[i]
        if type(arg) ~= "string" then
            arg = tostring(arg)
        end

        req[nbits] = "$"
        req[nbits + 1] = #arg
        req[nbits + 2] = "\r\n"
        req[nbits + 3] = arg
        req[nbits + 4] = "\r\n"

        nbits = nbits + 5
    end

    -- it is much faster to do string concatenation on the C land
    -- in real world (large number of strings in the Lua VM)
    return req
end


local function _do_cmd(self, ...)
    local args = {...}

    local sock = rawget(self, "_sock")
    if not sock then
        return nil, "not initialized"
    end

    local req = _gen_req(args)

    local reqs = rawget(self, "_reqs")
    if reqs then
        reqs[#reqs + 1] = req
        return
    end

    -- print("request: ", table.concat(req))

    local bytes, err = sock:send(req)
    if not bytes then
        return nil, err
    end

    return _read_reply(self, sock)
end


local function _check_subscribed(self, res)
    if type(res) == "table"
       and (res[1] == "unsubscribe" or res[1] == "punsubscribe")
       and res[3] == 0
   then
        self._subscribed = false
    end
end


function _M.read_reply(self)
    local sock = rawget(self, "_sock")
    if not sock then
        return nil, "not initialized"
    end

    if not rawget(self, "_subscribed") then
        return nil, "not subscribed"
    end

    local res, err = _read_reply(self, sock)
    _check_subscribed(self, res)

    return res, err
end


for i = 1, #common_cmds do
    local cmd = common_cmds[i]

    _M[cmd] =
        function (self, ...)
            return _do_cmd(self, cmd, ...)
        end
end


for i = 1, #sub_commands do
    local cmd = sub_commands[i]

    _M[cmd] =
        function (self, ...)
            self._subscribed = true
            return _do_cmd(self, cmd, ...)
        end
end


for i = 1, #unsub_commands do
    local cmd = unsub_commands[i]

    _M[cmd] =
        function (self, ...)
            local res, err = _do_cmd(self, cmd, ...)
            _check_subscribed(self, res)
            return res, err
        end
end


function _M.hmset(self, hashname, ...)
    if select('#', ...) == 1 then
        local t = select(1, ...)

        local n = 0
        for k, v in pairs(t) do
            n = n + 2
        end

        local array = new_tab(n, 0)

        local i = 0
        for k, v in pairs(t) do
            array[i + 1] = k
            array[i + 2] = v
            i = i + 2
        end
        -- print("key", hashname)
        return _do_cmd(self, "hmset", hashname, unpack(array))
    end

    -- backwards compatibility
    return _do_cmd(self, "hmset", hashname, ...)
end


function _M.init_pipeline(self, n)
    self._reqs = new_tab(n or 4, 0)
end


function _M.cancel_pipeline(self)
    self._reqs = nil
end


function _M.commit_pipeline(self)
    local reqs = rawget(self, "_reqs")
    if not reqs then
        return nil, "no pipeline"
    end

    self._reqs = nil

    local sock = rawget(self, "_sock")
    if not sock then
        return nil, "not initialized"
    end

    local bytes, err = sock:send(reqs)
    if not bytes then
        return nil, err
    end

    local nvals = 0
    local nreqs = #reqs
    local vals = new_tab(nreqs, 0)
    for i = 1, nreqs do
        local res, err = _read_reply(self, sock)
        if res then
            nvals = nvals + 1
            vals[nvals] = res

        elseif res == nil then
            if err == "timeout" then
                close(self)
            end
            return nil, err

        else
            -- be a valid redis error value
            nvals = nvals + 1
            vals[nvals] = {false, err}
        end
    end

    return vals
end


function _M.array_to_hash(self, t)
    local n = #t
    -- print("n = ", n)
    local h = new_tab(0, n / 2)
    for i = 1, n, 2 do
        h[t[i]] = t[i + 1]
    end
    return h
end


-- this method is deperate since we already do lazy method generation.
function _M.add_commands(...)
    local cmds = {...}
    for i = 1, #cmds do
        local cmd = cmds[i]
        _M[cmd] =
            function (self, ...)
                return _do_cmd(self, cmd, ...)
            end
    end
end


setmetatable(_M, {__index = function(self, cmd)
    local method =
        function (self, ...)
            return _do_cmd(self, cmd, ...)
        end

    -- cache the lazily generated method in our
    -- module table
    _M[cmd] = method
    return method
end})


return _M
```

## 7. 安装postman并测试nginx

安装直接百度即可，很容易

测试时输入红框内路径及添加请求头

![1550591246889](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1550591246889.png)