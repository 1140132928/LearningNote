# 心得总结

+ 软件形式化，可靠性，软件质量相关均可
+ 论文+联系
+ 课程内容+心得
+ 软件发展

| 对比角度 | 软件测试                       | 形式化验证                  |
| -------- | ------------------------------ | --------------------------- |
| 功能     | 只能找到bug，无法证明程序无bug | 通过数学逻辑可证明程序无bug |
| 环境     | 真实环境                       | 虚拟环境                    |
| 人员要求 | 入门门槛低                     | 数学要求很高                |

怎么把需求用数学形式表示出来

形式化：描述做什么，而不是怎么做

应用形式化方法的考虑：

+ 应用领域：看看项目特点，是否适合使用形式化方法
+ 规模结构：大规模分解，良好结构定义
+ 类型选择：确定应用形式化方法的目标
+ 形式化级别：非形式化，半形式化，高度形式化
+ 使用范围：软件开发的那个阶段使用（主要用于需求设计阶段）
+ 工具：合适工具的选择

软件缺陷

+ Fault：**静态存在**于软件的缺陷
+ Error：运行到Fault，引发的错误
+ Failure: Error传播到软件外部，**用户可观测**的失效行为

**bug/fault：测试用例判断**

+ 定义：根据fixing来判断（与测试用例相关）。每个bug有多种修复方式，原则上选择**最小修复（Minimal Fixing）**。
+ bug个数：发现错误的测试用例个数。尽可能使用发现错误能力强的测试用例。
+ 发生条件：
  + E：fault所在代码可执行
  + I：必须感染
  + P：传播到外面，被观察到

# 逻辑学基础

+ 如何把问题用符号表示？
+ 如何进行推理？

哥德尔定理

+ 完备性：一个命题真假是确定的
+ 一致性：无矛盾命题

例如：本句话是假的



命题逻辑：仅分解到原子命题，无法再细分

+ 存在问题：无法表现命题间的内部联系
+ 问题例子：苏格拉底三段论推理？

一阶逻辑（谓词逻辑）：克服命题逻辑的问题，能进一步拆分简单命题，找到内部联系和数量

个体词：主体或客体

+ 个体常项：a、b、c（具体常量）
+ 个体变项：x，y，z（抽象变量）

谓词：个体词的性质；多个个体词间关系

+ 常项
+ 变项：P(x1,x2,...,xn)为n元谓词，有时顺序是会影响结果的，除非满足对称性。最好保证顺序一致性。

量词

只有2是素数，5才是素数

F(x)：x是素数，x=2,5

F(5)->F(2)

三段论用一阶谓词表示

```
H(x):x是人
M(x):x会死
P: H(x)->M(x)
Q: H(苏格拉底)
R: M(苏格拉底)
命题判定：P & Q -> R
否命题!p反证法
```

引出量词（对个体词的取值范围进行限定）

+ 全称量词：真假判断类似于&&；所有人的共性-用推导
+ 存在量词：真假判断类似于||；部分人的特征-用交

谓词，个体词，要划分到什么程度，根据使用情况决定，够用就行。

注意每个量词的控制范围（作用域）

> 天下乌鸦一般黑（所有的乌鸦黑色程度一样）

P(x):x是乌鸦

Q(x):x是深黑色（RGB(0,0,0)）

$\forall x(P(x)\rightarrow  Q(x))$

> 没有人登上过木星

P(x)：x是人

Q(x)：x没有登上过木星

$\forall x(P(x)\rightarrow \lnot Q(x) )$

> 在美国留学的